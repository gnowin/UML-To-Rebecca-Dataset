
reactiveclass RootController(7)
{
       knownrebecs
       {
               PortController pController1;
               PortController pController2;
               PortController pController3;
//               PortController pController4;
//               PortController pController5;
       }
       statevars
       {
               byte rootID;
               byte rootDistance;
               byte myID;
               boolean IamRoot;
       }

       msgsrv initial(byte id)
       {
               myID = id;
               rootID = myID;
               rootDistance = 0;
               IamRoot = true;
               self.config();
       }

       msgsrv recvInf( byte senderID, byte distance, byte believedRootID)
       {
               if( believedRootID < rootID)
               {
                       rootID = believedRootID;
                       rootDistance = (byte)(distance + 1);
                       IamRoot = false;

                       //sender.setBestPort();                                               *
                       //if( sender != pController1)                                         *
                       if(true)
                       {
                               pController1.setBadPort();
                       }
                       //if( sender != pController2)                                         *
                       if(true)
                       {
                               pController2.setBadPort();
                       }
                       //if( sender != pController3)                                         *
                       if(true)
                       {
                               pController3.setBadPort();
                       }
                       //if( sender != pController4)                                         *
                       //if(true)
                       //{
                       //        pController4.setBadPort();
                       //}
                       //if( sender != pController5)                                         *
                       //if(true)
                       //{
                       //        pController5.setBadPort();
                       //}

                       //receive(best);                                                      *
                       //receive(bad);                                                       *
                       //receive(bad);                                                       *
                       //receive(bad);                                                       *
                       //receive(bad);                                                       *

                       pController1.sendLan( myID, rootDistance, rootID);
                       pController2.sendLan( myID, rootDistance, rootID);
                       pController3.sendLan( myID, rootDistance, rootID);
                       //pController4.sendLan( myID, rootDistance, rootID);
                       //pController5.sendLan( myID, rootDistance, rootID);
               }
               else
               {
                       if( believedRootID == rootID && distance + 1  < rootDistance)
                       {
                               rootID = believedRootID;
                               rootDistance = (byte)(distance + 1);
                               //sender.setBestPort();                                  *
                               //if( sender != pController1)                            *
                               if(true)
                               {
                                       pController1.setBadPort();
                               }
                               //if( sender != pController2)                            *
                               if(true)
                               {
                                       pController2.setBadPort();
                               }
                               //if( sender != pController3)                            *
                               if(true)
                               {
                                       pController3.setBadPort();
                               }
                               //if( sender != pController4)                            *
                               //if(true)
                               //{
                               //        pController4.setBadPort();
                               //}
                               //if( sender != pController5)                            *
                               //if(true)
                               //{
                               //        pController5.setBadPort();
                               //}

                               //receive( best);                                        *
                               //receive( bad);                                         *
                               //receive( bad);                                         *
                               //receive( bad);                                         *
                               //receive( bad);                                         *


                               pController1.sendLan( myID, rootDistance, rootID);
                               pController2.sendLan( myID, rootDistance, rootID);
                               pController3.sendLan( myID, rootDistance, rootID);
                               //pController4.sendLan( myID, rootDistance, rootID);
                               //pController5.sendLan( myID, rootDistance, rootID);
                       }
                       else
                       {
                            if(believedRootID == rootID && distance + 1 == rootDistance)
                            {}
                            else
                            {
                                self.config();
                            }
                       }
               }

       }
       msgsrv config()
       {
               if( IamRoot)
               {
                       pController1.sendLan( myID, 0, myID);
                       pController2.sendLan( myID, 0, myID);
                       pController3.sendLan( myID, 0, myID);
                       //pController4.sendLan( myID, 0, myID);
                       //pController5.sendLan( myID, 0, myID);
               }

       }
}
reactiveclass PortController(4)
{
     knownrebecs
     {
             RootController  rootController;
             BridgeToLanPort bridgeToLan;
             LanToBridgePort lanToBridge;
     }

     statevars
     {
             byte rootID;
             byte rootDistance;
             boolean isTheBestPort;
     }

     msgsrv initial()
     {
             rootID = (byte)255;
             rootDistance = (byte)255;
     }

     msgsrv setBestPort()
     {
             isTheBestPort = true;
             //rootController.best();                                           *
     }

     msgsrv setBadPort()
     {
             isTheBestPort = false;
             //rootController.bad();                                            *
     }

     msgsrv sendLan( byte senderID, byte distance, byte believedRootID)
     {
             if( believedRootID < rootID)
             {
                     bridgeToLan.turnOn();
                     //receive( alive);                                         *
                     bridgeToLan.send( senderID, distance, believedRootID);
                     //receive( sendToLan );                                    *
             }
             else
             {
                     if( believedRootID == rootID && distance < rootDistance )
                     {
                             bridgeToLan.turnOn();
                             //receive( alive);                                             *
                             bridgeToLan.send( senderID, distance, believedRootID);
                             //receive( sendToLan );                                        *
                     }
                     else
                     {
                             if( ! isTheBestPort)
                             {
                                     bridgeToLan.turnOff();
                                     //receive( died);                                      *
                             }
                     }
             }
     }
     msgsrv sendBridge( byte senderID, byte distance, byte believedRootID)
     {
             if( believedRootID < rootID)
             {
                  rootID = believedRootID;
                  rootDistance = (byte)(distance + 1);
             }
             else
             {
                if( believedRootID == rootID && distance < rootDistance )
                {
                    rootDistance = (byte)(distance + 1);
                }
             }
             rootController.recvInf( senderID, distance, believedRootID);
             //lanToBridge.sendToBridge();                                                  *
     }
}
reactiveclass BridgeToLanPort(3)
{
     knownrebecs
     {
             PortController portController;
             ExtendedLan lan;
     }

     statevars
     {
             boolean alive;
             byte myID;
     }

     msgsrv initial(byte id)
     {
             alive = true;
             myID = id;
     }
     msgsrv turnOn()
     {
             alive = true;
             //portController.alive();                                      *
     }

     msgsrv turnOff()
     {
             alive = false;
             //portController.died();                                       *
     }

     msgsrv send( byte senderID, byte distance, byte believedRootID)
     {
             if(alive)
             {
                     lan.recv(myID, senderID, distance, believedRootID);
             }
             //portController.sendToLan();                                  *
     }
}
reactiveclass LanToBridgePort(3)
{
     knownrebecs
     {
             PortController portController;
     }
     statevars
     {byte myID;}

     msgsrv initial(byte id)
     {
        myID = id;
     }

     msgsrv broadCast( byte portID , byte senderID, byte distance, byte believedRootID)
     {
             if(portID != myID)
             {
                portController.sendBridge( senderID, distance, believedRootID);
                //recieve(sendToBridge)                                                            *
             }

     }
}
reactiveclass ExtendedLan(3)
{
     knownrebecs
     {
             LanToBridgePort port1;
             LanToBridgePort port2;
     }

     statevars
     {}

     msgsrv initial()
     {}

     msgsrv recv(byte portID, byte senderID, byte distance, byte believedRootID)
     {
             //broadCast( portID, senderID, distance, believedRootID);
     }
}


main ////////////////////known objects binding
{
    RootController r1(p1D ,p1F ,p1D):(1);
    RootController r5(p5D ,p5B ,p5D):(5);
    RootController r7(p7F ,p7B ,p7K):(7);
    PortController p1D(r1 ,out1D ,in1D):();
    PortController p1F(r1 ,out1F ,in1F):();
    PortController p5D(r5 ,out5D ,in5D):();
    PortController p5B(r5 ,out5B ,in5B):();
    PortController p7F(r7 ,out7F ,in7F):();
    PortController p7B(r7 ,out7B ,in7B):();
    PortController p7K(r7 ,out7K ,in7K):();

    LanToBridgePort in1D(p1D):(1);
    LanToBridgePort in1F(p1F):(2);
    LanToBridgePort in5D(p5D):(3);
    LanToBridgePort in5B(p5B):(4);
    LanToBridgePort in7F(p7F):(5);
    LanToBridgePort in7B(p7B):(6);
    LanToBridgePort in7K(p7K):(7);

    BridgeToLanPort out1D(p1D,D):(1);
    BridgeToLanPort out1F(p1F,F):(2);
    BridgeToLanPort out5D(p5D,D):(3);
    BridgeToLanPort out5B(p5B,B):(4);
    BridgeToLanPort out7F(p7F,F):(5);
    BridgeToLanPort out7B(p7B,B):(6);
    BridgeToLanPort out7K(p7K,K):(7);

    ExtendedLan D(in1D, in5D):();
    ExtendedLan B(in7B, in5B):();
    ExtendedLan F(in1F, in7F):();
    ExtendedLan K(in7K, in7K):();
}